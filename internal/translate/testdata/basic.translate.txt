-- chan.go --
package basicgosim

import "log"

var chanLen = 10

func Test() {
	structCh := make(chan struct{})
	close(structCh)
	explicitZeroCh := make(chan struct{}, 0)
	close(explicitZeroCh)
	intChCh := make(chan chan int, 5)
	close(intChCh)

	var stringCh chan string

	stringCh <- "hello"
	log.Println(<-stringCh, <-stringCh)

	x, ok := <-stringCh
	x = <-stringCh
	x, ok = <-stringCh
	log.Println(x, ok)

	var y, yOk = <-stringCh
	log.Println(y, yOk)

	log.Println(len(structCh))
	log.Println(cap(structCh))

	rewriteLenCh := make(chan int, chanLen)
	close(rewriteLenCh)
}
-- translated/basic/chan.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"

	"github.com/kmrgirish/gosim/gosimruntime"
)

func Test() {
	structCh := gosimruntime.NewChan[struct{}](0)
	structCh.Close()
	explicitZeroCh := gosimruntime.NewChan[struct{}](0)
	explicitZeroCh.Close()
	intChCh := gosimruntime.NewChan[gosimruntime.Chan[int]](5)
	intChCh.Close()

	var stringCh gosimruntime.Chan[string]

	stringCh.Send("hello")
	log.Println(stringCh.Recv(), stringCh.Recv())

	x, ok := stringCh.RecvOk()
	x = stringCh.Recv()
	x, ok = stringCh.RecvOk()
	log.Println(x, ok)

	var y, yOk = stringCh.RecvOk()
	log.Println(y, yOk)

	log.Println(structCh.Len())
	log.Println(structCh.Cap())

	rewriteLenCh := gosimruntime.NewChan[int](G().chanLen)
	rewriteLenCh.Close()
}
-- chaniter.go --
package basicgosim

import "log"

func Chaniter() {
	var c chan string
	var v string

	for v := range c {
		log.Println(v)
	}

	for v = range c {
		log.Println(v)
	}

	for range c {
		log.Println()
	}

	for _ = range c {
		log.Println()
	}

	f := func() chan string {
		return c
	}

	for range f() {
	}
}
-- translated/basic/chaniter.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"

	"github.com/kmrgirish/gosim/gosimruntime"
)

func Chaniter() {
	var c gosimruntime.Chan[string]
	var v string

	for v := range c.Range() {
		log.Println(v)
	}

	for v = range c.Range() {
		log.Println(v)
	}

	for range c.Range() {
		log.Println()
	}

	for _ = range c.Range() {
		log.Println()
	}

	f := func() gosimruntime.Chan[string] {
		return c
	}

	for range f().Range() {
	}
}
-- chanshadow.go --
package basicgosim

import (
	"log"
)

func Chanshadow() {
	len := func(ch chan int) int {
		return -1
	}
	log.Println(len(make(chan int, 3)))
	close := func(ch chan int) {}
	close(make(chan int, 2))
}
-- translated/basic/chanshadow.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"

	"github.com/kmrgirish/gosim/gosimruntime"
)

func Chanshadow() {
	len := func(ch gosimruntime.Chan[int]) int {
		return -1
	}
	log.Println(len(gosimruntime.NewChan[int](3)))
	close := func(ch gosimruntime.Chan[int]) {}
	close(gosimruntime.NewChan[int](2))
}
-- chantypename.go --
package basicgosim

func Chantypename() {
	type Ch chan struct{}

	var ch chan struct{}

	_ = func() Ch {
		// implicit conversion
		// implicit conversion
		return ch
	}

	// implicit conversion
	var ch2 chan Ch
	ch2 <- ch

	var ch3 Ch = ch

	// all chan ops
	<-ch3          // recv
	x, ok := <-ch3 // recv ok
	_, _ = x, ok

	close(ch3)        // close
	_ = len(ch3)      // len
	_ = cap(ch3)      // cap
	ch3 <- struct{}{} // send
	for range ch3 {   // range
	}
	var ch4 = ch3
	select {
	case <-ch3: // recv selector
	case a, b := <-ch4: // recv selector
		_, _ = a, b
	case ch3 <- struct{}{}: // send selector
	}
	// optimized select recv
	select {
	case <-ch3:
	default:
	}
	// optimized select send
	select {
	case ch3 <- struct{}{}:
	default:
	}

}
-- translated/basic/chantypename.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import "github.com/kmrgirish/gosim/gosimruntime"

func Chantypename() {
	type Ch gosimruntime.Chan[struct{}]

	var ch gosimruntime.Chan[struct{}]

	_ = func() Ch {
		// implicit conversion
		// implicit conversion
		return Ch(ch)
	}

	// implicit conversion
	var ch2 gosimruntime.Chan[Ch]
	ch2.Send(Ch(ch))

	var ch3 Ch = ch

	// all chan ops
	gosimruntime.ExtractChan(ch3).Recv()            // recv
	x, ok := gosimruntime.ExtractChan(ch3).RecvOk() // recv ok
	_, _ = x, ok

	gosimruntime.ExtractChan(ch3).Close()   // close
	_ = gosimruntime.ExtractChan(ch3).Len() // len
	_ = gosimruntime.ExtractChan(ch3).Cap() // cap
	gosimruntime.ExtractChan(ch3).Send(struct{}{})
	for range gosimruntime.ExtractChan(ch3).Range() { // range
	}
	var ch4 = ch3
	switch idx0, val0, ok0 := gosimruntime.Select(gosimruntime.ExtractChan(ch3).RecvSelector(), gosimruntime.ExtractChan(ch4).RecvSelector(), gosimruntime.ExtractChan(ch3).SendSelector(struct{}{})); idx0 {
	case 0: // recv selector
	case 1: // recv selector
		a, b := gosimruntime.ChanCast[struct{}](val0), ok0
		_, _ = a, b
	case 2: // send selector
	default:
		panic("unreachable select")
	}
	// optimized select recv
	switch idx1, _, _ := gosimruntime.ExtractChan(ch3).SelectRecvOrDefault(); idx1 {
	case 0:
	default:
	}
	// optimized select send
	switch idx2, _, _ := gosimruntime.ExtractChan(ch3).SelectSendOrDefault(struct{}{}); idx2 {
	case 0:
	default:
	}

}
-- context.go --
package basicgosim

import (
	"context"
	"time"
)

func Context() {
	ctx := context.Background()

	_, cancel := context.WithCancel(ctx)
	defer cancel()

	_, cancel = context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	_, cancel = context.WithDeadline(ctx, time.Now().Add(10*time.Second))
	defer cancel()

	<-ctx.Done()
}
-- translated/basic/context.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/context"
	"translated/time"
)

func Context() {
	ctx := context.Background()

	_, cancel := context.WithCancel(ctx)
	defer cancel()

	_, cancel = context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	_, cancel = context.WithDeadline(ctx, time.Now().Add(10*time.Second))
	defer cancel()

	ctx.Done().Recv()
}
-- funccast.go --
package basicgosim

type Ftype func()

func (f Ftype) Invoke() {
	f()
}

func Funccast() {
	var f = Ftype(func() {})
	f()
	f.Invoke()
}
-- translated/basic/funccast.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

type Ftype func()

func (f Ftype) Invoke() {
	f()
}

func Funccast() {
	var f = Ftype(func() {})
	f()
	f.Invoke()
}
-- global.go --
package basicgosim

import (
	"log"
	"sync"

	"test/basic/global"
)

var x int
var y = "hello"

type Foo struct {
}

var m = Foo{}
var n Foo

var o *Foo
var p []Foo
var q map[Foo]Foo

var r = [...]string{"hello", "world"}
var s [3 * 3]string

var t <-chan string

var mm = map[Foo]int{
	m: 3,
}

var ()

type Yep[T any] struct {
	yep T
}

var u Yep[Yep[string]]

var mu sync.Map

var (
	deps1 = compute()
	deps3 = "foo"
)
var deps2 = deps3 + "bar"

func compute() string {
	return deps3 + deps2
}

func double() (string, string) {
	return "a", "b"
}

var (
	a, b           string = double()
	c, d                  = 2, 3.0
	_, interesting        = double()
	_                     = 3.0
	_                     = compute()
)

var _ = 10

func Global() {
	// XXX: take address of global?
	log.Println(x)
	x = 3
	x++
	x *= x

	log.Println(global.Hello)
}
-- translated/basic/global.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"

	"translated/test/basic/global"
)

type Foo struct {
}

type Yep[T any] struct {
	yep T
}

func compute() string {
	return G().deps3 + G().deps2
}

func double() (string, string) {
	return "a", "b"
}

func Global() {
	// XXX: take address of global?
	log.Println(G().x)
	G().x = 3
	G().x++
	G().x *= G().x

	log.Println(global.G().Hello)
}
-- translated/basic/global/gosim_globals.go --
// Code generated by gosim. DO NOT EDIT.
package global

import "github.com/kmrgirish/gosim/gosimruntime"

type Globals struct {
	Hello string
}

var globals gosimruntime.Global[Globals]

func initializers(initializeShared bool) {}
func G() *Globals                        { return globals.Get() }
func init() {
	gosimruntime.RegisterPackage("test/basic/global").Globals = &gosimruntime.Globals{Globals: &globals, Initializers: initializers}
}
-- global/nested.go --
package global

var Hello string
-- translated/basic/global/nested.go --
// Code generated by gosim. DO NOT EDIT.
package global
-- globalmaptricky.go --
package basicgosim

var (
	globalmaptricky map[string]int
)

func Globalmaptricky() {
	globalmaptricky["foo"]++
}
-- translated/basic/globalmaptricky.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

func Globalmaptricky() {
	map3, key3 := G().globalmaptricky, "foo"
	map3.Set(key3, map3.Get(key3)+1)
}
-- go.go --
package basicgosim

import (
	"log"
	"time"
)

func Go() {
	go func() {
		log.Println("hello!")
	}()

	x := 5
	y := "foo"
	go func(x int, y string) {
		log.Println(x, y)
	}(x, y)

	go func() error {
		return nil
	}()

	go func(s ...string) {
	}()

	go func(x *int, y string) {
	}(nil, y)

	go func(x time.Duration) {
	}(100)
}
-- translated/basic/go.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"
	"translated/time"

	"github.com/kmrgirish/gosim/gosimruntime"
)

func Go() {
	gosimruntime.Go(func() {
		log.Println("hello!")
	})

	x := 5
	y := "foo"
	gosimruntime.Go(Bind2_0(func(x int, y string) {
		log.Println(x, y)
	})(x, y))
	gosimruntime.Go(Bind0_1(func() error {
		return nil
	})())
	gosimruntime.Go(Bind1var_0(func(s ...string) {
	})())
	gosimruntime.Go(Bind2_0(func(x *int, y string) {
	})(nil, y))
	gosimruntime.Go(Bind1_0(func(x time.Duration) {
	})(100))
}
-- goglobal.go --
package basicgosim

var goglobalF func()
var goglobalF2 func(x int)

func Goglobal() {
	go goglobalF()
	go goglobalF2(10)
}
-- translated/basic/goglobal.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import "github.com/kmrgirish/gosim/gosimruntime"

func Goglobal() { gosimruntime.Go(G().goglobalF); gosimruntime.Go(Bind1_0(G().goglobalF2)(10)) }
-- translated/basic/gosim_globals.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/sync"

	"github.com/kmrgirish/gosim/gosimruntime"
)

type Globals struct {
	chanLen         int
	x               int
	y               string
	m               Foo
	n               Foo
	o               *Foo
	p               []Foo
	q               gosimruntime.Map[Foo, Foo]
	r               [2]string
	s               [9]string
	t               gosimruntime.Chan[string]
	mm              gosimruntime.Map[Foo, int]
	u               Yep[Yep[string]]
	mu              sync.Map
	deps1           string
	deps3           string
	deps2           string
	a               string
	b               string
	c               int
	d               float64
	interesting     string
	globalmaptricky gosimruntime.Map[string, int]
	goglobalF       func()
	goglobalF2      func(x int)
}

var globals gosimruntime.Global[Globals]

func initializers(initializeShared bool) {
	G().chanLen = 10
	G().y = "hello"
	G().m = Foo{}
	G().r = [...]string{"hello", "world"}
	G().mm = gosimruntime.MapLiteral([]gosimruntime.KV[Foo, int]{
		{K: G().m, V: 3},
	})
	G().deps3 = "foo"
	G().deps2 = G().deps3 + "bar"
	G().deps1 = compute()
	G().a, G().b = double()
	G().c = 2
	G().d = 3.0
	_, G().interesting = double()
	_ = 3.0
	_ = compute()
	_ = 10
	gosiminit0()
	gosiminit1()
}
func G() *Globals { return globals.Get() }
func init() {
	gosimruntime.RegisterPackage("test/basic").Globals = &gosimruntime.Globals{Globals: &globals, Initializers: initializers}
}
func Bind0_1[T1 any](f func() T1) func() func() {
	return func() func() {
		return func() {
			f()
		}
	}
}
func Bind1_0[T1 any](f func(v1 T1)) func(v1 T1) func() {
	return func(v1 T1) func() {
		return func() {
			f(v1)
		}
	}
}
func Bind1var_0[T1 any](f func(v1 ...T1)) func(v1 ...T1) func() {
	return func(v1 ...T1) func() {
		return func() {
			f(v1...)
		}
	}
}
func Bind2_0[T1, T2 any](f func(v1 T1, v2 T2)) func(v1 T1, v2 T2) func() {
	return func(v1 T1, v2 T2) func() {
		return func() {
			f(v1, v2)
		}
	}
}
-- implicitconversions.go --
package basicgosim

func Implicitconversions() {
	type M map[int]int
	var a M
	var b map[int]int

	// assign
	a = b

	// call
	f := func(m M) {}
	f(b)

	// call vararg
	g := func(x int, m ...M) {}
	g(1, a, b, a, b)

	// return
	_ = func() M {
		return b
	}

	// return complicated
	_ = func() (M, map[int]int, int, M) {
		return b, b, b[1], b
	}

	// struct field
	type X struct{ A M }
	_ = X{A: b}

	// slice literal
	_ = []M{b}

	// array literal
	_ = [1]M{b}

	// map literal value
	_ = map[int]M{0: b}

	// map literal key: channels are comparable
	type C chan int
	var aa C
	var bb chan int
	_ = map[C]int{bb: 0}

	// send
	var ch = make(chan M)
	ch <- b

	// compare
	_ = aa == bb

	_ = a
	_ = b
	_ = aa
	_ = bb
}
-- translated/basic/implicitconversions.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import "github.com/kmrgirish/gosim/gosimruntime"

func Implicitconversions() {
	type M gosimruntime.Map[int, int]
	var a M
	var b gosimruntime.Map[int, int]

	// assign
	a = M(b)

	// call
	f := func(m M) {}
	f(M(b))

	// call vararg
	g := func(x int, m ...M) {}
	g(1, a, M(b), a, M(b))

	// return
	_ = func() M {
		return M(b)
	}

	// return complicated
	_ = func() (M, gosimruntime.Map[int, int], int, M) {
		return M(b), b, b.Get(1), M(b)
	}

	// struct field
	type X struct{ A M }
	_ = X{A: M(b)}

	// slice literal
	_ = []M{M(b)}

	// array literal
	_ = [1]M{M(b)}

	// map literal value
	_ = gosimruntime.MapLiteral([]gosimruntime.KV[int, M]{{K: 0, V: M(b)}})

	// map literal key: channels are comparable
	type C gosimruntime.Chan[int]
	var aa C
	var bb gosimruntime.Chan[int]
	_ = gosimruntime.MapLiteral([]gosimruntime.KV[C, int]{{K: C(bb), V: 0}})

	// send
	var ch = gosimruntime.NewChan[M](0)
	ch.Send(M(b))

	// compare
	_ = aa == C(bb)

	_ = a
	_ = b
	_ = aa
	_ = bb
}
-- init.go --
package basicgosim

import "log"

func init() {
	log.Println("hello")
}

func Init() {

}

type S struct {
}

func (s S) init() {
}

func init() {
	log.Println("hello")
}
-- translated/basic/init.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import "translated/log"

func gosiminit0() {
	log.Println("hello")
}

func Init() {

}

type S struct {
}

func (s S) init() {
}

func gosiminit1() {
	log.Println("hello")
}
-- translated/basic/justinit/gosim_globals.go --
// Code generated by gosim. DO NOT EDIT.
package justinit

import "github.com/kmrgirish/gosim/gosimruntime"

type Globals struct {
}

var globals gosimruntime.Global[Globals]

func initializers(initializeShared bool) { gosiminit0() }
func G() *Globals                        { return globals.Get() }
func init() {
	gosimruntime.RegisterPackage("test/basic/justinit").Globals = &gosimruntime.Globals{Globals: &globals, Initializers: initializers}
}
-- justinit/main.go --
package justinit

import (
	"log"
)

func init() {
	log.Println("HELLO")
}
-- translated/basic/justinit/main.go --
// Code generated by gosim. DO NOT EDIT.
package justinit

import (
	"translated/log"
)

func gosiminit0() {
	log.Println("HELLO")
}
-- log.go --
package basicgosim

import (
	"log"
)

func Log() {
	log.Printf("hello %s!", "you")
	log.Print("a", "b", "c")
}
-- translated/basic/log.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"
)

func Log() {
	log.Printf("hello %s!", "you")
	log.Print("a", "b", "c")
}
-- map.go --
package basicgosim

import (
	"log"
)

type StructWithMap struct {
	x int
	y map[int]string
}

func Map() {
	var m map[int]string
	m = make(map[int]string)

	m = map[int]string{1: "ok", 2: "bar"}

	m = map[int]string{
		1: "ok",
		2: "bar",
	}

	if m == nil {
	}

	_ = StructWithMap{0, nil}

	log.Println(len(m))
	var x []int
	log.Println(len(x))

	m[0] = "ok"
	delete(m, 1)
	m[0] = m[1] + m[2]
	v, ok := m[3]
	v, ok = m[3]
	log.Println(v, ok)
	m[0] += "lol"

	var y, yOk = m[9]
	log.Println(y, yOk)

	mi := make(map[int]int)
	mi[0]++
	mi[0]--

	mi[mi[0]]++
	delete(mi, mi[0])
}
-- translated/basic/map.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"

	"github.com/kmrgirish/gosim/gosimruntime"
)

type StructWithMap struct {
	x int
	y gosimruntime.Map[int, string]
}

func Map() {
	var m gosimruntime.Map[int, string]
	m = gosimruntime.NewMap[int, string]()

	m = gosimruntime.MapLiteral([]gosimruntime.KV[int, string]{{K: 1, V: "ok"}, {K: 2, V: "bar"}})

	m = gosimruntime.MapLiteral([]gosimruntime.KV[int, string]{
		{K: 1, V: "ok"},
		{K: 2, V: "bar"},
	})

	if m == gosimruntime.NilMap[int, string]() {
	}

	_ = StructWithMap{0, gosimruntime.NilMap[int, string]()}

	log.Println(m.Len())
	var x []int
	log.Println(len(x))

	m.Set(0, "ok")
	m.Delete(1)
	m.Set(0, m.Get(1)+m.Get(2))
	v, ok := m.GetOk(3)
	v, ok = m.GetOk(3)
	log.Println(v, ok)
	map4, key4 := m, 0
	map4.Set(key4, map4.Get(key4)+"lol")

	var y, yOk = m.GetOk(9)
	log.Println(y, yOk)

	mi := gosimruntime.NewMap[int, int]()
	map5, key5 := mi, 0
	map5.Set(key5, map5.Get(key5)+1)
	map6, key6 := mi, 0
	map6.Set(key6, map6.Get(key6)-1)

	map7, key7 := mi, mi.Get(0)

	map7.Set(key7, map7.Get(key7)+1)
	mi.Delete(mi.Get(0))
}
-- mapconversions.go --
package basicgosim

func takeany(x any) {
}

type Named map[string]string

func Mapconversions() {
	takeany(map[string]string{"foo": "bar"})
	var x map[string]string
	_ = x
	x = nil
	takeany(x)

	var y Named
	_ = y
	y = x
	x = y
	y = nil
	takeany(y)
}
-- translated/basic/mapconversions.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import "github.com/kmrgirish/gosim/gosimruntime"

func takeany(x any) {
}

type Named gosimruntime.Map[string, string]

func Mapconversions() {
	takeany(gosimruntime.MapLiteral([]gosimruntime.KV[string, string]{{K: "foo", V: "bar"}}))
	var x gosimruntime.Map[string, string]
	_ = x
	x = gosimruntime.NilMap[string, string]()
	takeany(x)

	var y Named
	_ = y
	y = Named(x)
	x = gosimruntime.Map[string, string](y)
	y = Named(gosimruntime.NilMap[string, string]())
	takeany(y)
}
-- mapimplictslice.go --
package basicgosim

func Mapimplicitslice() {
	type Alias map[string]string

	var x []Alias = []Alias{
		map[string]string{"huh": "ok"},
	}
	_ = x

	var y [2]Alias = [2]Alias{
		map[string]string{"huh": "ok"},
	}
	_ = y
}
-- translated/basic/mapimplictslice.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import "github.com/kmrgirish/gosim/gosimruntime"

func Mapimplicitslice() {
	type Alias gosimruntime.Map[string, string]

	var x []Alias = []Alias{Alias(gosimruntime.MapLiteral([]gosimruntime.KV[string, string]{{K: "huh", V: "ok"}}))}
	_ = x

	var y [2]Alias = [2]Alias{Alias(gosimruntime.MapLiteral([]gosimruntime.KV[string, string]{{K: "huh", V: "ok"}}))}
	_ = y
}
-- mapiter.go --
package basicgosim

import "log"

func Mapiter() {
	var m map[int]string
	var k int
	var v string

	for k, v := range m {
		log.Println(k, v)
	}

	for k, v = range m {
		log.Println(k, v)
	}

	for range m {
		log.Println()
	}

	for _ = range m {
		log.Println()
	}

	for k := range m {
		log.Println(k)
	}

	for k, _ := range m {
		log.Println(k)
	}

	for k, _ = range m {
		log.Println(k)
	}

	for _, v := range m {
		log.Println(v)
	}

	for _, _ = range m {
		log.Println()
	}

	func() {
		for _, _ = range m {
			log.Println()
		}
		func() {
			for _, _ = range m {
				log.Println()
			}
		}()
	}()
}
-- translated/basic/mapiter.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"

	"github.com/kmrgirish/gosim/gosimruntime"
)

func Mapiter() {
	var m gosimruntime.Map[int, string]
	var k int
	var v string

	for k, v := range m.Range() {
		log.Println(k, v)
	}

	for k, v = range m.Range() {
		log.Println(k, v)
	}

	for range m.Range() {
		log.Println()
	}

	for _ = range m.Range() {
		log.Println()
	}

	for k := range m.Range() {
		log.Println(k)
	}

	for k, _ := range m.Range() {
		log.Println(k)
	}

	for k, _ = range m.Range() {
		log.Println(k)
	}

	for _, v := range m.Range() {
		log.Println(v)
	}

	for _, _ = range m.Range() {
		log.Println()
	}

	func() {
		for _, _ = range m.Range() {
			log.Println()
		}
		func() {
			for _, _ = range m.Range() {
				log.Println()
			}
		}()
	}()
}
-- mapliteralrange.go --
package basicgosim

import "log"

func Mapliteralrange() {
	for k, v := range map[int]int{
		1: 1,
		2: 2,
	} {
		log.Println(k, v)
	}
}
-- translated/basic/mapliteralrange.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"

	"github.com/kmrgirish/gosim/gosimruntime"
)

func Mapliteralrange() {
	for k, v := range gosimruntime.MapLiteral([]gosimruntime.KV[int, int]{
		{K: 1, V: 1},
		{K: 2, V: 2},
	}).Range() {
		log.Println(k, v)
	}
}
-- mapmultiassign.go --
package basicgosim

func Mapmultiassign() {
	var m1 = map[int]string{}
	var m2 = map[int]int{}

	var foo int
	var bar string

	m1[0], m2[1] = "3", 4
	m1[0], m2[1], foo = "3", 4, 5
	m1[0], bar, foo = "3", "4", 5
	bar, m1[0], m1[1], foo = "3", "4", "5", 6

	_ = foo
	_ = bar
}
-- translated/basic/mapmultiassign.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import "github.com/kmrgirish/gosim/gosimruntime"

func Mapmultiassign() {
	var m1 = gosimruntime.MapLiteral([]gosimruntime.KV[int, string]{})
	var m2 = gosimruntime.MapLiteral([]gosimruntime.KV[int, int]{})

	var foo int
	var bar string

	var val8 string
	var val9 int

	val8, val9 = "3", 4

	m2.Set(1, val9)

	m1.Set(0, val8)
	var val10 string
	var val11 int
	val10, val11, foo = "3", 4, 5
	m2.Set(1, val11)
	m1.Set(0, val10)
	var val12 string
	val12, bar, foo = "3", "4", 5
	m1.Set(0, val12)
	var val13 string
	var val14 string
	bar, val13, val14, foo = "3", "4", "5", 6

	m1.Set(1, val14)

	m1.Set(0, val13)

	_ = foo
	_ = bar
}
-- mapnested.go --
package basicgosim

import "log"

func Mapnested() {
	var m map[string]map[string]string
	m = make(map[string]map[string]string)
	m["foo"] = make(map[string]string)
	m["foo"]["bar"] = "baz"
	log.Println(m["foo"]["bar"])
	m = map[string]map[string]string{}
	m = map[string]map[string]string{
		"foo": {
			"bar": "baz",
		},
	}
	m["foo"] = map[string]string{
		"bar": "baz",
	}

	triple := map[int]map[int]map[int]int{
		0: {0: {0: 0}},
		1: {1: {1: 1}},
	}
	log.Print(triple)

	// XXX: named nested map here

	x := map[string]map[string][]byte{
		"a": {"a": {}},
		"b": map[string][]byte{"a": {0}},
	}
	log.Print(x)

	for k := range x {
		for _, v := range x[k] {
			log.Print(v)
		}
	}
}
-- translated/basic/mapnested.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"

	"github.com/kmrgirish/gosim/gosimruntime"
)

func Mapnested() {
	var m gosimruntime.Map[string, gosimruntime.Map[string, string]]
	m = gosimruntime.NewMap[string, gosimruntime.Map[string, string]]()
	m.Set("foo", gosimruntime.NewMap[string, string]())
	m.Get("foo").Set("bar", "baz")
	log.Println(m.Get("foo").Get("bar"))
	m = gosimruntime.MapLiteral([]gosimruntime.KV[string, gosimruntime.Map[string, string]]{})
	m = gosimruntime.MapLiteral([]gosimruntime.KV[string, gosimruntime.Map[string, string]]{
		{K: "foo", V: gosimruntime.MapLiteral([]gosimruntime.KV[string, string]{
			{K: "bar", V: "baz"},
		})},
	})
	m.Set("foo", gosimruntime.MapLiteral([]gosimruntime.KV[string, string]{
		{K: "bar", V: "baz"},
	}))

	triple := gosimruntime.MapLiteral([]gosimruntime.KV[int, gosimruntime.Map[int, gosimruntime.Map[int, int]]]{
		{K: 0, V: gosimruntime.MapLiteral([]gosimruntime.KV[int, gosimruntime.Map[int, int]]{{K: 0, V: gosimruntime.MapLiteral([]gosimruntime.KV[int, int]{{K: 0, V: 0}})}})},
		{K: 1, V: gosimruntime.MapLiteral([]gosimruntime.KV[int, gosimruntime.Map[int, int]]{{K: 1, V: gosimruntime.MapLiteral([]gosimruntime.KV[int, int]{{K: 1, V: 1}})}})},
	})
	log.Print(triple)

	// XXX: named nested map here

	x := gosimruntime.MapLiteral([]gosimruntime.KV[string, gosimruntime.Map[string, []byte]]{
		{K: "a", V: gosimruntime.MapLiteral([]gosimruntime.KV[string, []byte]{{K: "a", V: []byte{}}})},
		{K: "b", V: gosimruntime.MapLiteral([]gosimruntime.KV[string, []byte]{{K: "a", V: []byte{0}}})},
	})
	log.Print(x)

	for k := range x.Range() {
		for _, v := range x.Get(k).Range() {
			log.Print(v)
		}
	}
}
-- mapptr.go --
package basicgosim

func Mapptr() {
	type S struct {
		A string
	}
	_ = map[int]*S{
		1: {A: "a"},
	}
}
-- translated/basic/mapptr.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import "github.com/kmrgirish/gosim/gosimruntime"

func Mapptr() {
	type S struct {
		A string
	}
	_ = gosimruntime.MapLiteral([]gosimruntime.KV[int, *S]{
		{K: 1, V: &S{A: "a"}},
	})
}
-- mapshadow.go --
package basicgosim

import (
	"log"
)

func Mapshadow() {
	len := func(a map[string]int) int {
		return -1
	}
	log.Println(len(map[string]int{}))
	delete := func(a map[string]int, b string) {}
	delete(map[string]int{}, "foo")
}
-- translated/basic/mapshadow.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"

	"github.com/kmrgirish/gosim/gosimruntime"
)

func Mapshadow() {
	len := func(a gosimruntime.Map[string, int]) int {
		return -1
	}
	log.Println(len(gosimruntime.MapLiteral([]gosimruntime.KV[string, int]{})))
	delete := func(a gosimruntime.Map[string, int], b string) {}
	delete(gosimruntime.MapLiteral([]gosimruntime.KV[string, int]{}), "foo")
}
-- mutex.go --
package basicgosim

import "sync"

func Mutex() {
	var mu sync.Mutex
	mu.Lock()
	defer mu.Unlock()
}
-- translated/basic/mutex.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import "translated/sync"

func Mutex() {
	var mu sync.Mutex
	mu.Lock()
	defer mu.Unlock()
}
-- os.go --
package basicgosim

import (
	"log"
	"os"
)

func Os() {
	f, err := os.OpenFile("foo", os.O_RDONLY, 0)
	if err != nil {
		log.Fatal(err)
	}
	f.Close()
	var g *os.File
	log.Println(g)
	g = f
	os.Remove("foo")
	fi, _ := os.Stat("foo")
	var s string = fi.Name()
	var b bool = fi.IsDir()
	log.Print(s, b)
	os.Rename("a", "b")
	var entries []os.DirEntry
	entries, err = os.ReadDir(".")
	s = entries[0].Name()
	b = entries[0].IsDir()
}
-- translated/basic/os.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"
	"translated/os"
)

func Os() {
	f, err := os.OpenFile("foo", os.O_RDONLY, 0)
	if err != nil {
		log.Fatal(err)
	}
	f.Close()
	var g *os.File
	log.Println(g)
	g = f
	os.Remove("foo")
	fi, _ := os.Stat("foo")
	var s string = fi.Name()
	var b bool = fi.IsDir()
	log.Print(s, b)
	os.Rename("a", "b")
	var entries []os.DirEntry
	entries, err = os.ReadDir(".")
	s = entries[0].Name()
	b = entries[0].IsDir()
}
-- rand.go --
package basicgosim

import (
	"log"
	"math/rand"
)

func Rand() {
	log.Println(rand.Float64())
}
-- translated/basic/rand.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"
	"translated/math/rand"
)

func Rand() {
	log.Println(rand.Float64())
}
-- rand_timer.go --
package basicgosim

import (
	"log"
	"math/rand"
	"time"
)

func RandTimer() {
	t := time.NewTimer(10 * time.Second)
	t.Reset(time.Duration(rand.Float64() * float64(10*time.Second)))
	log.Println(<-t.C)
}
-- translated/basic/rand_timer.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"
	"translated/math/rand"
	"translated/time"
)

func RandTimer() {
	t := time.NewTimer(10 * time.Second)
	t.Reset(time.Duration(rand.Float64() * float64(10*time.Second)))
	log.Println(t.C.Recv())
}
-- time.go --
package basicgosim

import (
	"log"
	"time"
)

func Time() {
	t := time.Now()
	log.Println(t)
	time.Sleep(5 * time.Second)
	log.Println(time.Since(t))
	log.Println(time.Until(t))

	var x *time.Timer
	x = time.NewTimer(5 * time.Second)
	log.Println(x)

	ch := time.After(5 * time.Second)
	log.Println(ch)
	x = time.AfterFunc(5*time.Second, func() {})

	var tt *time.Ticker
	tt = time.NewTicker(10 * time.Second)
	var q time.Time
	q = <-tt.C
	log.Println(q)
	tt.Stop()
	tt.Reset(5 * time.Second)
}
-- translated/basic/time.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/log"
	"translated/time"
)

func Time() {
	t := time.Now()
	log.Println(t)
	time.Sleep(5 * time.Second)
	log.Println(time.Since(t))
	log.Println(time.Until(t))

	var x *time.Timer
	x = time.NewTimer(5 * time.Second)
	log.Println(x)

	ch := time.After(5 * time.Second)
	log.Println(ch)
	x = time.AfterFunc(5*time.Second, func() {})

	var tt *time.Ticker
	tt = time.NewTicker(10 * time.Second)
	var q time.Time
	q = tt.C.Recv()
	log.Println(q)
	tt.Stop()
	tt.Reset(5 * time.Second)
}
-- waitgroup.go --
package basicgosim

import "sync"

func Waitgroup() {
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
	}()
	wg.Wait()
}
-- translated/basic/waitgroup.go --
// Code generated by gosim. DO NOT EDIT.
package basicgosim

import (
	"translated/sync"

	"github.com/kmrgirish/gosim/gosimruntime"
)

func Waitgroup() {
	var wg sync.WaitGroup
	wg.Add(1)
	gosimruntime.Go(func() {
		defer wg.Done()
	})
	wg.Wait()
}
